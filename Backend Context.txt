Backend Context

package.json
`
{
  "name": "hwd-backend",
  "version": "1.0.0",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "nodemon src/app.js",
    "start": "node src/app.js",
    "migrate": "node run-migration.js",
    "lint": "echo 'no linter configured'"
  },
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cors": "^2.8.5",
    "dotenv": "^16.4.5",
    "express": "^4.19.2",
    "express-validator": "^7.2.0",
    "jsonwebtoken": "^9.0.2",
    "multer": "^1.4.5-lts.1",
    "sequelize": "^6.37.7",
    "mysql2": "^3.11.3",
    "sqlite3": "^5.1.7",
    "xlsx": "^0.18.5"
  },
  "devDependencies": {
    "nodemon": "^3.0.1"
  }
}

`

src\core\db.js
`
import { Sequelize } from 'sequelize';

const rawDialect = process.env.DB_DIALECT || 'mysql';
// Guard against misformatted env like: "mysql, DB_HOST=127.0.0.1, ..."
const dialect = rawDialect.split(',')[0].trim().toLowerCase();

export const sequelize = new Sequelize(
  process.env.DB_NAME || 'hwd_db',
  process.env.DB_USER || 'root',
  process.env.DB_PASSWORD || '',
  {
    host: process.env.DB_HOST || '127.0.0.1',
    port: Number(process.env.DB_PORT) || 3306,
    dialect,
    storage: dialect === 'sqlite' ? (process.env.DB_STORAGE || 'hwd.sqlite') : undefined,
    logging: false,
  }
);

`

src\core\error-middleware.js
`
export function errorMiddleware(err, _req, res, _next) {
  const status = err.status || 500;
  const message = err.message || 'Internal Server Error';
  const details = err.details;
  res.status(status).json({ error: message, details });
}


`

src\core\models.js
`
import { DataTypes } from 'sequelize';
import { sequelize } from './db.js';

export const Admin = sequelize.define('admin', {
  admin_id: { type: DataTypes.INTEGER, autoIncrement: true, primaryKey: true },
  username: { type: DataTypes.STRING, unique: true, allowNull: false },
  password_hash: { type: DataTypes.STRING, allowNull: false },
});

export const Dmag = sequelize.define('dmag', {
  employee_no: { type: DataTypes.STRING, primaryKey: true },
  employee_name: { type: DataTypes.STRING, allowNull: false },
  department: { type: DataTypes.STRING },
  age: { type: DataTypes.INTEGER },
  gender: { type: DataTypes.ENUM('Male', 'Female') },
});

export const Event = sequelize.define('event', {
  event_id: { type: DataTypes.INTEGER, autoIncrement: true, primaryKey: true },
  event_type: { type: DataTypes.STRING, allowNull: false },
  event_name: { type: DataTypes.STRING, allowNull: false },
  event_date: { type: DataTypes.DATEONLY, allowNull: false },
}, {
  indexes: [
    {
      unique: true,
      fields: ['event_type', 'event_name']
    }
  ]
});

export const Registration = sequelize.define('registration', {
  reg_id: { type: DataTypes.INTEGER, autoIncrement: true, primaryKey: true },
  employee_no: { type: DataTypes.STRING },
  employee_name: { type: DataTypes.STRING },
  department: { type: DataTypes.STRING },
  event_id: { type: DataTypes.INTEGER, allowNull: false },
});

export const Attendance = sequelize.define('attendance', {
  attendance_id: { type: DataTypes.INTEGER, autoIncrement: true, primaryKey: true },
  employee_no: { type: DataTypes.STRING },
  employee_name: { type: DataTypes.STRING },
  department: { type: DataTypes.STRING },
  mode_of_attendance: { type: DataTypes.ENUM('Virtual', 'Onsite'), allowNull: false },
  validation_status: { type: DataTypes.ENUM('Registered', 'Not Registered'), defaultValue: 'Not Registered' },
  event_id: { type: DataTypes.INTEGER, allowNull: false },
});

export function registerModels() {
  Registration.belongsTo(Event, { foreignKey: 'event_id' });
  Event.hasMany(Registration, { foreignKey: 'event_id' });

  Attendance.belongsTo(Event, { foreignKey: 'event_id' });
  Event.hasMany(Attendance, { foreignKey: 'event_id' });
}

export async function syncDb() {
  await sequelize.sync();
}
`

attendance.routes.js
`
import { Router } from 'express';
import multer from 'multer';
import XLSX from 'xlsx';
import { body, validationResult } from 'express-validator';
import { sequelize } from '../../core/db.js';
import { Attendance, Event, Registration } from '../../core/models.js';
import { requireAuth } from '../_shared/auth-middleware.js';
import { Op } from 'sequelize';

const upload = multer({ storage: multer.memoryStorage() });
export const attendanceRouter = Router();

// Helper to compute validation status
async function computeValidationStatus(employeeNo, eventId) {
  if (!employeeNo || employeeNo === 'NA') return 'Not Registered';
  const match = await Registration.findOne({
    where: { employee_no: String(employeeNo), event_id: eventId }
  });
  return match ? 'Registered' : 'Not Registered';
}

// GET /attendance - Paginated list with unified case-insensitive search and filters
attendanceRouter.get('/', requireAuth, async (req, res, next) => {
  try {
    const { 
      page = 1, 
      limit = 10, 
      sort = 'attendance_id', 
      order = 'DESC', 
      event_id,
      employee_no,
      search 
    } = req.query;
    const offset = (Number(page) - 1) * Number(limit);
    
    const where = {};
    if (event_id) where.event_id = Number(event_id);
    if (employee_no) {
      where.employee_no = { [Op.iLike]: `%${employee_no}%` };
    }
    if (search) {
      where[Op.or] = [
        { employee_name: { [Op.iLike]: `%${search}%` } },
        { employee_no: { [Op.iLike]: `%${search}%` } }
      ];
    }
    
    const include = [{
      model: Event,
      attributes: ['event_id', 'event_name']
    }];
    
    const { count, rows } = await Attendance.findAndCountAll({
      where,
      include,
      order: [[sort, order.toUpperCase()]],
      limit: Number(limit),
      offset
    });
    
    res.json({
      attendance: rows,
      pagination: {
        total: count,
        page: Number(page),
        limit: Number(limit),
        totalPages: Math.ceil(count / limit)
      }
    });
  } catch (e) {
    console.error('GET /attendance error:', e);
    next(e);
  }
});

// GET /attendance/template - Download Excel template
attendanceRouter.get('/template', requireAuth, async (req, res, next) => {
  try {
    // Fetch all events for reference sheet
    const events = await Event.findAll({ attributes: ['event_id', 'event_name'] });

    // Create main template sheet
    const templateData = [
      ['Employee No', 'Employee Name', 'Department', 'Mode of Attendance', 'Event Name'], // Headers
      ['EMP001', 'John Doe', 'IT', 'Onsite', 'Sample Event'] // Sample row
    ];
    const ws = XLSX.utils.aoa_to_sheet(templateData);

    // Create events reference sheet
    const eventsData = [['Event ID', 'Event Name']];
    events.forEach(event => eventsData.push([event.event_id, event.event_name]));
    const eventsWs = XLSX.utils.aoa_to_sheet(eventsData);

    // Bundle into workbook
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Attendance Template');
    XLSX.utils.book_append_sheet(wb, eventsWs, 'Events Reference');

    // Write and send as download
    const buffer = XLSX.write(wb, { type: 'buffer', bookType: 'xlsx' });
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    res.setHeader('Content-Disposition', 'attachment; filename=attendance-template.xlsx');
    res.send(buffer);
  } catch (e) {
    console.error('GET /attendance/template error:', e);
    next(e);
  }
});

// POST /attendance - Create new attendance
attendanceRouter.post(
  '/',
  requireAuth,
  [
    body('employee_no').optional().trim(),
    body('employee_name').optional().isString().trim(),
    body('department').optional().isString().trim(),
    body('mode_of_attendance').isIn(['Virtual', 'Onsite']),
    body('event_id').optional().isInt({ min: 1 }),
    body('event_name').optional().isString().trim()
  ],
  async (req, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({ error: 'Validation failed', details: errors.array() });
      }
      
      let { event_id, event_name, employee_no, employee_name, department, mode_of_attendance } = req.body;
      const finalEmployeeNo = employee_no?.trim() || null;
      const finalEmployeeName = employee_name?.trim() || null;
      
      // Resolve event_id if event_name provided
      if (event_name && !event_id) {
        const event = await Event.findOne({ where: { event_name: event_name.trim() } });
        if (!event) return res.status(404).json({ error: 'Event not found' });
        event_id = event.event_id;
      }
      if (!event_id) return res.status(400).json({ error: 'Event ID or Name required' });

      // Require name for walk-ins
      if (!finalEmployeeNo && !finalEmployeeName) {
        return res.status(400).json({ error: 'Employee Name required for walk-ins' });
      }

      // Duplicate check: employee_no + event_id OR employee_name + event_id (case-insensitive for name)
      const orConditions = [];
      if (finalEmployeeNo) orConditions.push({ employee_no: finalEmployeeNo });
      if (finalEmployeeName) {
        orConditions.push(sequelize.where(
          sequelize.fn('LOWER', sequelize.col('employee_name')),
          sequelize.fn('LOWER', finalEmployeeName)
        ));
      }
      const existing = await Attendance.findOne({
        where: {
          event_id: Number(event_id),
          [Op.or]: orConditions
        }
      });
      
      if (existing) {
        return res.status(409).json({ 
          error: 'Duplicate attendance found',
          details: `Attendance for "${finalEmployeeName || finalEmployeeNo}" in event ${event_id} already exists`
        });
      }
      
      const validation_status = await computeValidationStatus(finalEmployeeNo, event_id);
      
      const created = await Attendance.create({
        employee_no: finalEmployeeNo,
        employee_name: finalEmployeeName,
        department: department?.trim() || null,
        mode_of_attendance,
        validation_status,
        event_id: Number(event_id)
      });
      
      res.status(201).json(created);
    } catch (e) {
      if (e.name === 'SequelizeUniqueConstraintError') {
        return res.status(409).json({ error: 'Duplicate attendance', details: 'Unique constraint violated' });
      }
      next(e);
    }
  }
);

// PUT /attendance/:id - Update attendance
attendanceRouter.put(
  '/:id',
  requireAuth,
  [
    body('employee_no').optional().trim(),
    body('employee_name').optional().isString().trim(),
    body('department').optional().isString().trim(),
    body('mode_of_attendance').optional().isIn(['Virtual', 'Onsite']),
    body('event_id').optional().isInt({ min: 1 }),
    body('event_name').optional().isString().trim()
  ],
  async (req, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) return res.status(400).json({ error: 'Validation failed', details: errors.array() });
      
      const attendance = await Attendance.findByPk(req.params.id);
      if (!attendance) return res.status(404).json({ error: 'Attendance not found' });
      
      let { event_id, event_name, employee_no, employee_name, department, mode_of_attendance } = req.body;
      const updateData = {};
      
      if (event_name) {
        const event = await Event.findOne({ where: { event_name: event_name.trim() } });
        if (!event) return res.status(404).json({ error: 'Event not found' });
        event_id = event.event_id;
      }
      if (event_id) updateData.event_id = Number(event_id);
      
      const finalEmployeeNo = employee_no?.trim() || null;
      const finalEmployeeName = employee_name?.trim() || null;
      
      // Require name for walk-ins
      if (!finalEmployeeNo && !finalEmployeeName) {
        return res.status(400).json({ error: 'Employee Name required for walk-ins' });
      }

      if (finalEmployeeNo !== undefined) updateData.employee_no = finalEmployeeNo;
      if (finalEmployeeName !== undefined) updateData.employee_name = finalEmployeeName;
      if (department !== undefined) updateData.department = department?.trim() || null;
      if (mode_of_attendance) updateData.mode_of_attendance = mode_of_attendance;

      // Duplicate check excluding self
      const orConditions = [];
      if (updateData.employee_no) orConditions.push({ employee_no: updateData.employee_no });
      if (updateData.employee_name) {
        orConditions.push(sequelize.where(
          sequelize.fn('LOWER', sequelize.col('employee_name')),
          sequelize.fn('LOWER', updateData.employee_name)
        ));
      }
      if (orConditions.length > 0) {
        const existing = await Attendance.findOne({
          where: {
            event_id: updateData.event_id || attendance.event_id,
            [Op.or]: orConditions,
            attendance_id: { [Op.ne]: req.params.id }
          }
        });
        if (existing) return res.status(409).json({ error: 'Duplicate attendance found' });
      }
      
      // Recompute validation status if employee_no or event_id changed
      const newEmployeeNo = updateData.employee_no !== undefined ? updateData.employee_no : attendance.employee_no;
      const newEventId = updateData.event_id || attendance.event_id;
      updateData.validation_status = await computeValidationStatus(newEmployeeNo, newEventId);
      
      await attendance.update(updateData);
      res.json(attendance);
    } catch (e) {
      next(e);
    }
  }
);

// DELETE /attendance/:id
attendanceRouter.delete('/:id', requireAuth, async (req, res, next) => {
  try {
    const attendance = await Attendance.findByPk(req.params.id);
    if (!attendance) return res.status(404).json({ error: 'Attendance not found' });
    await attendance.destroy();
    res.status(204).send();
  } catch (e) {
    console.error('DELETE /attendance/:id error:', e);
    next(e);
  }
});

// POST /attendance/bulk-delete
attendanceRouter.post('/bulk-delete', requireAuth, async (req, res, next) => {
  try {
    const { ids } = req.body;
    if (!Array.isArray(ids) || ids.length === 0) {
      return res.status(400).json({ error: 'Invalid or empty IDs array' });
    }
    await Attendance.destroy({ where: { attendance_id: { [Op.in]: ids } } });
    res.status(204).send();
  } catch (e) {
    console.error('POST /attendance/bulk-delete error:', e);
    next(e);
  }
});

// POST /attendance/upload - Bulk upload from Excel
attendanceRouter.post('/upload', requireAuth, upload.single('file'), async (req, res, next) => {
  try {
    if (!req.file) return res.status(400).json({ error: 'No file uploaded' });
    
    const workbook = XLSX.read(req.file.buffer, { type: 'buffer' });
    const sheet = workbook.Sheets[workbook.SheetNames[0]];
    const rows = XLSX.utils.sheet_to_json(sheet, { header: 1, raw: false, defval: '' });
    
    if (rows.length < 2) return res.status(400).json({ error: 'Empty or invalid sheet' });
    
    const headers = rows[0].map(h => h.toString().trim().toLowerCase());
    const requiredHeaders = ['employee no', 'employee name', 'department', 'mode of attendance', 'event name'];
    for (const req of requiredHeaders) {
      if (!headers.includes(req)) return res.status(400).json({ error: `Missing header: ${req}` });
    }
    
    const created = [];
    const skipped = [];
    const seen = new Map(); // key: employee_no_event_id or NA_event_id_name_lower
    
    for (let i = 1; i < rows.length; i++) {
      const row = {};
      headers.forEach((h, idx) => row[h] = rows[i][idx]?.toString().trim() || '');
      
      const event_name = row['event name'];
      if (!event_name) {
        skipped.push({ ...row, reason: 'Missing Event Name' });
        continue;
      }
      const event = await Event.findOne({ where: { event_name } });
      if (!event) {
        skipped.push({ ...row, reason: `Event "${event_name}" not found` });
        continue;
      }
      
      const mode = row['mode of attendance'].toLowerCase();
      if (!['virtual', 'onsite'].includes(mode)) {
        skipped.push({ ...row, reason: 'Invalid Mode of Attendance (must be Virtual or Onsite)' });
        continue;
      }
      
      let finalEmployeeNo = row['employee no'] || 'NA';
      const rawEmployeeName = row['employee name'];
      if (finalEmployeeNo === 'NA' && !rawEmployeeName) {
        skipped.push({ ...row, reason: 'Employee Name required for walk-ins' });
        continue;
      }
      
      let key;
      if (finalEmployeeNo === 'NA') {
        key = `NA_${event.event_id}_${rawEmployeeName.toLowerCase()}`;
      } else {
        key = `${finalEmployeeNo}_${event.event_id}`;
      }
      
      if (seen.has(key)) {
        const reason = finalEmployeeNo === 'NA' 
          ? `Duplicate walk-in "${rawEmployeeName}" for event "${event_name}"`
          : `Duplicate employee "${finalEmployeeNo}" for event "${event_name}"`;
        skipped.push({ ...row, reason });
        continue;
      }
      seen.set(key, true);

      // --- DB DUPLICATE CHECK (in addition to in-file seen) ---
      const dbWhere = {
        event_id: event.event_id,
        [Op.or]: []
      };
      if (finalEmployeeNo && finalEmployeeNo !== 'NA') {
        dbWhere[Op.or].push({ employee_no: finalEmployeeNo });
      }
      if (rawEmployeeName) {
        dbWhere[Op.or].push(
          sequelize.where(
            sequelize.fn('LOWER', sequelize.col('employee_name')),
            sequelize.fn('LOWER', rawEmployeeName)
          )
        );
      }

      const dbExisting = dbWhere[Op.or].length > 0
        ? await Attendance.findOne({ where: dbWhere })
        : null;

      if (dbExisting) {
        const reason = finalEmployeeNo && finalEmployeeNo !== 'NA'
          ? `Employee ${finalEmployeeNo} already attended "${event_name}"`
          : `Walk-in "${rawEmployeeName}" already recorded for "${event_name}"`;
        skipped.push({ ...row, reason });
        continue;
      }
      // --- END DB CHECK ---
      
      const validation_status = await computeValidationStatus(finalEmployeeNo !== 'NA' ? finalEmployeeNo : null, event.event_id);
      
      const record = await Attendance.create({
        employee_no: finalEmployeeNo !== 'NA' ? finalEmployeeNo : null,
        employee_name: rawEmployeeName || null,
        department: row['department'] || null,
        mode_of_attendance: mode.charAt(0).toUpperCase() + mode.slice(1),
        validation_status,
        event_id: event.event_id
      });
      created.push(record);
    }
    
    const response = { inserted: created.length };
    if (skipped.length > 0) {
      response.skipped = skipped.length;
      response.skip_details = skipped;
    }
    res.json(response);
  } catch (e) {
    console.error('POST /attendance/upload error:', e);
    next(e);
  }
});


// GET /attendance/export - Export filtered attendance as Excel
attendanceRouter.get('/export', requireAuth, async (req, res, next) => {
  try {
    const { event_id, search, sort = 'attendance_id', order = 'DESC' } = req.query;

    const where = {};
    if (event_id) where.event_id = Number(event_id);
    if (search) {
      where[Op.or] = [
        { employee_name: { [Op.iLike]: `%${search}%` } },
        { employee_no: { [Op.iLike]: `%${search}%` } }
      ];
    }

    const rows = await Attendance.findAll({
      where,
      include: [{ model: Event, attributes: ['event_name'] }],
      order: [[sort, order.toUpperCase()]],
      raw: true,
      nest: true
    });

    const data = rows.map(r => ({
      'Attendance ID': r.attendance_id,
      'Employee No': r.employee_no || 'N/A',
      'Employee Name': r.employee_name || 'N/A',
      'Department': r.department || 'N/A',
      'Mode of Attendance': r.mode_of_attendance,
      'Validation Status': r.validation_status,
      'Event Name': r.event?.event_name || 'N/A'
    }));

    const ws = XLSX.utils.json_to_sheet(data);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Attendance');

    const buffer = XLSX.write(wb, { type: 'buffer', bookType: 'xlsx' });

    res.setHeader(
      'Content-Type',
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    );
    res.setHeader(
      'Content-Disposition',
      `attachment; filename=attendance-export-${new Date().toISOString().slice(0, 10)}.xlsx`
    );
    res.send(buffer);
  } catch (e) {
    console.error('GET /attendance/export error:', e);
    next(e);
  }
});
`


auth.routes.js
`
import { Router } from 'express';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { body, validationResult } from 'express-validator';
import { Admin } from '../../core/models.js';

export const authRouter = Router();

authRouter.post(
  '/login',
  [body('username').isString().notEmpty(), body('password').isString().notEmpty()],
  async (req, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({ errors: errors.array() });
      }
      const { username, password } = req.body;
      const admin = await Admin.findOne({ where: { username } });
      if (!admin) return res.status(401).json({ error: 'Invalid credentials' });
      const ok = await bcrypt.compare(password, admin.password_hash);
      if (!ok) return res.status(401).json({ error: 'Invalid credentials' });
      const token = jwt.sign({ sub: admin.admin_id, username }, process.env.JWT_SECRET || 'dev_secret', { expiresIn: '8h' });
      res.json({ token });
    } catch (e) {
      next(e);
    }
  }
);



`

events.routes.js
`
import { Router } from 'express';
import multer from 'multer';
import XLSX from 'xlsx';
import { body, validationResult } from 'express-validator';
import { sequelize } from '../../core/db.js';
import { Event } from '../../core/models.js';
import { requireAuth } from '../_shared/auth-middleware.js';
import { Op } from 'sequelize';

const upload = multer({ storage: multer.memoryStorage() });
export const eventsRouter = Router();

eventsRouter.get('/', requireAuth, async (req, res, next) => {
  try {
    const { 
      page = 1, 
      limit = 10, 
      sort = 'event_id', 
      order = 'DESC', 
      type,
      name,
      date,
      search  // New: unified search param
    } = req.query;
    const offset = (Number(page) - 1) * Number(limit);
    
    const where = {};
    
    // Handle separate filters
    if (type) where.event_type = { [Op.like]: `%${type}%` };
    if (name) where.event_name = { [Op.like]: `%${name}%` };
    if (date) where.event_date = { [Op.eq]: date };
    
    // Handle unified search: OR across name and type (case-insensitive)
    if (search) {
      where[Op.or] = [
        { event_name: { [Op.iLike]: `%${search}%` } },
        { event_type: { [Op.iLike]: `%${search}%` } }
      ];
      console.log(`Search query: "${search}" (filtered ${res.locals.eventCount || 'N/A'} events)`); // Optional logging
    }
    
    const { count, rows } = await Event.findAndCountAll({
      where,
      order: [[sort, order.toUpperCase()]],
      limit: Number(limit),
      offset
    });
    
    res.json({
      events: rows,
      pagination: {
        total: count,
        page: Number(page),
        limit: Number(limit),
        totalPages: Math.ceil(count / limit)
      }
    });
  } catch (e) {
    console.error('GET /events error:', e);
    next(e);
  }
});

// Deprecated: Use GET /?search= instead (remove in v2)
eventsRouter.get('/search', requireAuth, async (req, res, next) => {
  try {
    const { type, name } = req.query;
    const where = {};
    if (type) where.event_type = { [Op.like]: `%${type}%` };
    if (name) where.event_name = { [Op.like]: `%${name}%` };
    const events = await Event.findAll({ where, order: [['event_name', 'ASC']], raw: true });
    res.json(events.map(e => ({ id: e.event_id, label: `${e.event_type}: ${e.event_name}` })));
  } catch (e) {
    next(e);
  }
});

eventsRouter.post(
  '/',
  requireAuth,
  [
    body('event_type').isString().notEmpty().trim(),
    body('event_name').isString().notEmpty().trim(),
    body('event_date').isDate({ format: 'YYYY-MM-DD' }),
  ],
  async (req, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) return res.status(400).json({ error: 'Validation failed', details: errors.array() });
      
      // Check for duplicate event
      const existingEvent = await Event.findOne({
        where: {
          event_type: req.body.event_type.trim(),
          event_name: req.body.event_name.trim()
        }
      });
      
      if (existingEvent) {
        return res.status(409).json({ 
          error: 'Duplicate event found', 
          details: `Event "${req.body.event_name.trim()}" of type "${req.body.event_type.trim()}" already exists` 
        });
      }
      
      const created = await Event.create({
        event_type: req.body.event_type.trim(),
        event_name: req.body.event_name.trim(),
        event_date: req.body.event_date
      });
      res.status(201).json(created);
    } catch (e) {
      if (e.name === 'SequelizeUniqueConstraintError') {
        return res.status(409).json({ 
          error: 'Duplicate event found', 
          details: 'Event type and name combination must be unique' 
        });
      }
      next(e);
    }
  }
);

eventsRouter.put(
  '/:id',
  requireAuth,
  [
    body('event_type').optional().isString().trim(),
    body('event_name').optional().isString().trim(),
    body('event_date').optional().isDate({ format: 'YYYY-MM-DD' }),
  ],
  async (req, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) return res.status(400).json({ error: 'Validation failed', details: errors.array() });
      const event = await Event.findByPk(req.params.id);
      if (!event) return res.status(404).json({ error: 'Event not found' });
      
      const updateData = {
        event_type: req.body.event_type ? req.body.event_type.trim() : event.event_type,
        event_name: req.body.event_name ? req.body.event_name.trim() : event.event_name,
        ...(req.body.event_date && { event_date: req.body.event_date })
      };
      
      // Check for duplicate (excluding current)
      const existingEvent = await Event.findOne({
        where: {
          event_type: updateData.event_type,
          event_name: updateData.event_name,
          event_id: { [Op.ne]: req.params.id }
        }
      });
      
      if (existingEvent) {
        return res.status(409).json({ 
          error: 'Duplicate event found', 
          details: `Event "${updateData.event_name}" of type "${updateData.event_type}" already exists` 
        });
      }
      
      await event.update(updateData);
      res.json(event);
    } catch (e) {
      next(e);
    }
  }
);

eventsRouter.delete('/:id', requireAuth, async (req, res, next) => {
  try {
    const event = await Event.findByPk(req.params.id);
    if (!event) return res.status(404).json({ error: 'Event not found' });
    await event.destroy();
    res.json({ message: 'Event deleted successfully' });
  } catch (e) {
    next(e);
  }
});

// Helper to parse Excel/CSV dates (handles string, number, empty)
function parseExcelDate(cell) {
  if (!cell || cell === '') return null;  // Explicit null for invalid/empty

  if (typeof cell === 'string') {
    const trimmed = cell.trim();
    const d = new Date(trimmed);
    if (!isNaN(d.getTime()) && d.getFullYear() > 1900) {
      return d.toISOString().split('T')[0];  // YYYY-MM-DD
    }
    // Manual parse for MM/DD/YYYY or DD-MM-YYYY
    const parts = trimmed.split(/[-\/]/);
    if (parts.length === 3) {
      const nums = parts.map(p => parseInt(p.trim(), 10));
      if (!isNaN(nums[0]) && !isNaN(nums[1]) && !isNaN(nums[2])) {
        // Guess format: if first part > 12, assume YYYY; else MM/DD/YYYY
        if (nums[0] > 31) {  // Likely YYYY
          return `${nums[0]}-${String(nums[1]).padStart(2, '0')}-${String(nums[2]).padStart(2, '0')}`;
        } else {
          return `${nums[2]}-${String(nums[0]).padStart(2, '0')}-${String(nums[1]).padStart(2, '0')}`;
        }
      }
    }
  } else if (typeof cell === 'number' && cell > 25569) {  // Excel serial date (post-1900)
    const utc_days = Math.floor(cell - 25569);
    const utc_value = utc_days * 86400;
    const date_info = new Date(utc_value * 1000);
    return `${date_info.getUTCFullYear()}-${String(date_info.getUTCMonth() + 1).padStart(2, '0')}-${String(date_info.getUTCDate()).padStart(2, '0')}`;
  }

  return null;  // Invalid
}

eventsRouter.post('/upload', requireAuth, upload.single('file'), async (req, res, next) => {
  try {
    const { buffer } = req.file || {};
    if (!buffer) return res.status(400).json({ error: 'No file uploaded' });
    const workbook = XLSX.read(buffer, { type: 'buffer' });
    const sheet = workbook.Sheets[workbook.SheetNames[0]];
    const rows = XLSX.utils.sheet_to_json(sheet, { defval: '' });
    const created = [];
    const skipped = [];
    for (const row of rows) {
      const event_type = (row['Event Type'] || '').trim();
      const event_name = (row['Event Name'] || '').trim();
      const event_date_raw = row['Event Date'];
      const event_date = parseExcelDate(event_date_raw);

      // Skip if required fields missing/invalid
      let reason = '';
      if (!event_type) reason = 'Missing event type';
      else if (!event_name) reason = 'Missing event name';
      else if (!event_date) reason = 'Invalid event date';
      if (reason) {
        skipped.push({
          event_type,
          event_name,
          reason,  // Descriptive reason
          date_raw: event_date_raw  // For debugging
        });
        console.warn(`Skipping invalid row: ${reason} - ${event_type} - ${event_name} (${event_date_raw})`);
        continue;
      }

      // Check for duplicate before create
      const existing = await Event.findOne({
        where: {
          event_type,
          event_name
        }
      });
      if (existing) {
        skipped.push({
          event_type,
          event_name,
          reason: `Duplicate event "${event_name}" of type "${event_type}"`
        });
        console.warn(`Skipping duplicate: ${event_type} - ${event_name}`);
        continue;
      }

      const record = await Event.create({
        event_type,
        event_name,
        event_date
      });
      created.push(record);
    }
    const response = { inserted: created.length };
    if (skipped.length > 0) {
      response.skipped = skipped.length;
      response.skip_details = skipped;  // Includes event_name, event_type, reason for frontend display
    }
    res.json(response);
  } catch (e) {
    if (e.name === 'SequelizeUniqueConstraintError') {
      return res.status(409).json({ 
        error: 'Duplicate event found', 
        details: 'One or more records violate unique constraints on type/name' 
      });
    }
    console.error('POST /events/upload error:', e);
    next(e);
  }
});`

registration.routes.js

`
import { Router } from 'express';
import multer from 'multer';
import XLSX from 'xlsx';
import { body, validationResult } from 'express-validator';
import { sequelize } from '../../core/db.js';
import { Registration, Event } from '../../core/models.js';
import { requireAuth } from '../_shared/auth-middleware.js';
import { Op } from 'sequelize';

const upload = multer({ storage: multer.memoryStorage() });
export const registrationsRouter = Router();

// GET /registrations - Paginated list with unified case-insensitive search and filters
registrationsRouter.get('/', requireAuth, async (req, res, next) => {
  try {
    const { 
      page = 1, 
      limit = 10, 
      sort = 'reg_id', 
      order = 'DESC', 
      event_id,
      employee_no,
      search 
    } = req.query;
    const offset = (Number(page) - 1) * Number(limit);
    
    const where = {};
    if (event_id) where.event_id = Number(event_id);
    if (employee_no) {
      where.employee_no = { [Op.iLike]: `%${employee_no}%` };
    }
    if (search) {
      where[Op.or] = [
        { employee_name: { [Op.iLike]: `%${search}%` } },
        { employee_no: { [Op.iLike]: `%${search}%` } }
      ];
    }
    
    const include = [{
      model: Event,
      attributes: ['event_id', 'event_name']
    }];
    
    const { count, rows } = await Registration.findAndCountAll({
      where,
      include,
      order: [[sort, order.toUpperCase()]],
      limit: Number(limit),
      offset
    });
    
    res.json({
      registrations: rows,
      pagination: {
        total: count,
        page: Number(page),
        limit: Number(limit),
        totalPages: Math.ceil(count / limit)
      }
    });
  } catch (e) {
    console.error('GET /registrations error:', e);
    next(e);
  }
});

// GET /registrations/template - Download Excel template
registrationsRouter.get('/template', requireAuth, async (req, res, next) => {
  try {
    // Fetch all events for reference sheet
    const events = await Event.findAll({ attributes: ['event_id', 'event_name'] });

    // Create main template sheet
    const templateData = [
      ['Employee No', 'Employee Name', 'Department', 'Event Name'], // Headers
      ['EMP001', 'John Doe', 'IT', 'Sample Event'] // Sample row
    ];
    const ws = XLSX.utils.aoa_to_sheet(templateData);

    // Create events reference sheet
    const eventsData = [['Event ID', 'Event Name']];
    events.forEach(event => eventsData.push([event.event_id, event.event_name]));
    const eventsWs = XLSX.utils.aoa_to_sheet(eventsData);

    // Bundle into workbook
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Registrations Template');
    XLSX.utils.book_append_sheet(wb, eventsWs, 'Events Reference');

    // Write and send as download
    const buffer = XLSX.write(wb, { type: 'buffer', bookType: 'xlsx' });
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    res.setHeader('Content-Disposition', 'attachment; filename=registrations-template.xlsx');
    res.send(buffer);
  } catch (e) {
    console.error('GET /registrations/template error:', e);
    next(e);
  }
});

// POST /registrations - Create new registration
registrationsRouter.post(
  '/',
  requireAuth,
  [
    body('employee_no').optional().trim(),
    body('employee_name').isString().notEmpty().trim(),
    body('department').optional().isString().trim(),
    body('event_id').isInt({ min: 1 })
  ],
  async (req, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({ error: 'Validation failed', details: errors.array() });
      }
      
      const { event_id, employee_no, employee_name, department } = req.body;
      const finalEmployeeNo = employee_no?.trim() || null;
      
      // Duplicate check: employee_no + event_id OR employee_name + event_id (case-insensitive for name)
      const existing = await Registration.findOne({
        where: {
          event_id: Number(event_id),
          [Op.or]: [
            finalEmployeeNo ? { employee_no: finalEmployeeNo } : null,
            sequelize.where(
              sequelize.fn('LOWER', sequelize.col('employee_name')),
              sequelize.fn('LOWER', employee_name.trim())
            )
          ].filter(Boolean)
        }
      });
      
      if (existing) {
        return res.status(409).json({ 
          error: 'Duplicate registration found',
          details: `Registration for "${employee_name.trim()}" in event ${event_id} already exists`
        });
      }
      
      const created = await Registration.create({
        employee_no: finalEmployeeNo,
        employee_name: employee_name.trim(),
        department: department?.trim() || null,
        event_id: Number(event_id)
      });
      
      res.status(201).json(created);
    } catch (e) {
      if (e.name === 'SequelizeUniqueConstraintError') {
        return res.status(409).json({ error: 'Duplicate registration', details: 'Unique constraint violated' });
      }
      next(e);
    }
  }
);

// PUT /registrations/:id - Update registration
registrationsRouter.put(
  '/:id',
  requireAuth,
  [
    body('employee_no').optional().trim(),
    body('employee_name').optional().isString().trim(),
    body('department').optional().isString().trim(),
    body('event_id').optional().isInt({ min: 1 })
  ],
  async (req, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) return res.status(400).json({ error: 'Validation failed', details: errors.array() });
      
      const registration = await Registration.findByPk(req.params.id);
      if (!registration) return res.status(404).json({ error: 'Registration not found' });
      
      const { event_id, employee_no, employee_name, department } = req.body;
      const updateData = {
        ...(employee_name && { employee_name: employee_name.trim() }),
        ...(employee_no && { employee_no: employee_no.trim() }),
        ...(department && { department: department.trim() }),
        ...(event_id && { event_id: Number(event_id) })
      };
      
      // Duplicate check excluding self (case-insensitive for name)
      const existing = await Registration.findOne({
        where: {
          ...updateData,
          reg_id: { [Op.ne]: req.params.id },
          [Op.or]: [
            updateData.employee_no ? { employee_no: updateData.employee_no } : null,
            updateData.employee_name ? sequelize.where(
              sequelize.fn('LOWER', sequelize.col('employee_name')),
              sequelize.fn('LOWER', updateData.employee_name)
            ) : null
          ].filter(Boolean)
        }
      });
      
      if (existing) {
        return res.status(409).json({ error: 'Duplicate registration found' });
      }
      
      await registration.update(updateData);
      res.json(registration);
    } catch (e) {
      next(e);
    }
  }
);

// DELETE /registrations/:id
registrationsRouter.delete('/:id', requireAuth, async (req, res, next) => {
  try {
    const registration = await Registration.findByPk(req.params.id);
    if (!registration) return res.status(404).json({ error: 'Registration not found' });
    await registration.destroy();
    res.json({ message: 'Registration deleted successfully' });
  } catch (e) {
    next(e);
  }
});

// POST /registrations/upload - Excel upload with parsing, in-file + DB duplicate checks, and skipping
registrationsRouter.post('/upload', requireAuth, upload.single('file'), async (req, res, next) => {
  try {
    const { buffer } = req.file || {};
    if (!buffer) return res.status(400).json({ error: 'No file uploaded' });
    
    const workbook = XLSX.read(buffer, { type: 'buffer' });
    const sheet = workbook.Sheets[workbook.SheetNames[0]];
    const rows = XLSX.utils.sheet_to_json(sheet, { defval: '' });
    
    const created = [];
    const skipped = [];
    const seen = new Map(); // Track in-file duplicates: employee_no_event_id or lowercase_name_event_id
    
    for (const row of rows) {
      const rawEmployeeNo = (row['Employee No'] || '').toString().trim();
      const rawEmployeeName = (row['Employee Name'] || '').toString().trim();
      const rawDepartment = (row['Department'] || '').toString().trim();
      const event_name = (row['Event Name'] || '').toString().trim();
      
      if (!rawEmployeeName || rawEmployeeName.length < 2) {
        skipped.push({ ...row, reason: 'Invalid or missing Employee Name' });
        continue;
      }
      
      // Find event by name (case-insensitive)
      const event = await Event.findOne({
        where: sequelize.where(
          sequelize.fn('LOWER', sequelize.col('event_name')),
          sequelize.fn('LOWER', event_name)
        )
      });
      
      if (!event) {
        skipped.push({ ...row, reason: `Event "${event_name}" not found` });
        continue;
      }
      
      const finalEmployeeNo = rawEmployeeNo || null; // null for walk-ins
      const key = finalEmployeeNo 
        ? `${finalEmployeeNo}_${event.event_id}` 
        : `NA_${event.event_id}_${rawEmployeeName.toLowerCase()}`;
      
      // Check in-file duplicates first
      if (seen.has(key)) {
        const reason = finalEmployeeNo 
          ? `Duplicate employee "${finalEmployeeNo}" for event "${event_name}" (in file)`
          : `Duplicate walk-in "${rawEmployeeName}" for event "${event_name}" (in file)`;
        skipped.push({ ...row, reason });
        console.warn(`Upload skipping in-file duplicate: ${key}`);
        continue;
      }
      
      // Check DB duplicates
      const existingInDb = await Registration.findOne({
        where: {
          event_id: event.event_id,
          [Op.or]: [
            finalEmployeeNo ? { employee_no: finalEmployeeNo } : null,
            sequelize.where(
              sequelize.fn('LOWER', sequelize.col('employee_name')),
              rawEmployeeName.toLowerCase()
            )
          ].filter(Boolean)
        }
      });
      
      if (existingInDb) {
        const reason = finalEmployeeNo 
          ? `Employee "${finalEmployeeNo}" already registered for event "${event_name}"`
          : `Walk-in "${rawEmployeeName}" already registered for event "${event_name}"`;
        skipped.push({ ...row, reason });
        console.warn(`Upload skipping DB duplicate: ${key}`);
        continue;
      }
      
      // Safe to insert
      seen.set(key, true);
      const record = await Registration.create({
        employee_no: finalEmployeeNo,
        employee_name: rawEmployeeName,
        department: rawDepartment || null,
        event_id: event.event_id,
      });
      created.push(record);
    }
    
    const response = { inserted: created.length };
    if (skipped.length > 0) {
      response.skipped = skipped.length;
      response.skip_details = skipped;
    }
    console.log(`Upload completed: ${response.inserted} inserted, ${response.skipped || 0} skipped`);
    res.json(response);
  } catch (e) {
    console.error('POST /registrations/upload error:', e);
    next(e);
  }
});

// GET /registrations/departments - Existing route for departments (unchanged)
registrationsRouter.get('/departments', requireAuth, async (req, res, next) => {
  try {
    const departments = await sequelize.query(
      `SELECT DISTINCT department as department FROM dmags WHERE department IS NOT NULL ORDER BY department`,
      { type: sequelize.QueryTypes.SELECT }
    );
    res.json(departments.map(d => d.department).filter(Boolean));
  } catch (e) {
    console.error('GET /registrations/departments error:', e);
    next(e);
  }
});

// GET /registrations/export - Export filtered data as XLSX
registrationsRouter.get('/export', requireAuth, async (req, res, next) => {
  try {
    const { event_id, search } = req.query;
    
    const where = {};
    if (event_id) where.event_id = Number(event_id);
    if (search) {
      where[Op.or] = [
        { employee_name: { [Op.iLike]: `%${search}%` } },
        { employee_no: { [Op.iLike]: `%${search}%` } }
      ];
    }
    
    const include = [{
      model: Event,
      attributes: ['event_name']
    }];
    
    const records = await Registration.findAll({
      where,
      include,
      order: [['reg_id', 'ASC']]
    });
    
    // Prepare data for XLSX (CSV-like: flat array of arrays)
    const data = [
      ['ID', 'Employee No', 'Employee Name', 'Department', 'Event Name'], // Headers
      ...records.map(r => [
        r.reg_id,
        r.employee_no || '',
        r.employee_name,
        r.department || '',
        r.event?.event_name || ''
      ])
    ];
    
    const ws = XLSX.utils.aoa_to_sheet(data);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Registrations');
    
    const buffer = XLSX.write(wb, { type: 'buffer', bookType: 'xlsx' });
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    res.setHeader('Content-Disposition', 'attachment; filename=registrations-export.xlsx');
    res.send(buffer);
  } catch (e) {
    console.error('GET /registrations/export error:', e);
    next(e);
  }
});

registrationsRouter.post('/bulk-delete', requireAuth, async (req, res, next) => {
  try {
    const { ids } = req.body;
    await Registration.destroy({ where: { reg_id: ids } });
    res.json({ message: 'Deleted' });
  } catch (e) { next(e); }
});`

cleanup-duplicates.js
`
import { sequelize } from '../core/db.js';
import { Registration, Attendance, Event } from '../core/models.js';

export async function cleanupDuplicates() {
  try {
    console.log('Starting duplicate cleanup...');
    
    // Clean up duplicate registrations
    console.log('Cleaning up duplicate registrations...');
    const duplicateRegistrations = await sequelize.query(`
      SELECT employee_no, event_id, COUNT(*) as count
      FROM registrations 
      WHERE employee_no IS NOT NULL
      GROUP BY employee_no, event_id 
      HAVING COUNT(*) > 1
    `, { type: sequelize.QueryTypes.SELECT });

    for (const duplicate of duplicateRegistrations) {
      console.log(`Found ${duplicate.count} duplicates for employee ${duplicate.employee_no} in event ${duplicate.event_id}`);
      
      // Keep only the first record, delete the rest
      const records = await Registration.findAll({
        where: {
          employee_no: duplicate.employee_no,
          event_id: duplicate.event_id
        },
        order: [['reg_id', 'ASC']]
      });
      
      // Delete all but the first record
      for (let i = 1; i < records.length; i++) {
        await records[i].destroy();
        console.log(`Deleted duplicate registration ID: ${records[i].reg_id}`);
      }
    }

    // Clean up duplicate attendance
    console.log('Cleaning up duplicate attendance...');
    const duplicateAttendance = await sequelize.query(`
      SELECT employee_no, event_id, COUNT(*) as count
      FROM attendance 
      WHERE employee_no IS NOT NULL
      GROUP BY employee_no, event_id 
      HAVING COUNT(*) > 1
    `, { type: sequelize.QueryTypes.SELECT });

    for (const duplicate of duplicateAttendance) {
      console.log(`Found ${duplicate.count} duplicates for employee ${duplicate.employee_no} in event ${duplicate.event_id}`);
      
      // Keep only the first record, delete the rest
      const records = await Attendance.findAll({
        where: {
          employee_no: duplicate.employee_no,
          event_id: duplicate.event_id
        },
        order: [['attendance_id', 'ASC']]
      });
      
      // Delete all but the first record
      for (let i = 1; i < records.length; i++) {
        await records[i].destroy();
        console.log(`Deleted duplicate attendance ID: ${records[i].attendance_id}`);
      }
    }

    console.log('Duplicate cleanup completed successfully!');
    
    // Now add the unique constraints
    console.log('Adding unique constraints...');
    
    try {
      await sequelize.query(`
        ALTER TABLE registrations 
        ADD UNIQUE INDEX registrations_employee_no_event_id (employee_no, event_id)
      `);
      console.log('Added unique constraint for registrations');
    } catch (error) {
      if (error.code === 'ER_DUP_KEYNAME') {
        console.log('Unique constraint for registrations already exists');
      } else {
        throw error;
      }
    }

    try {
      await sequelize.query(`
        ALTER TABLE attendance 
        ADD UNIQUE INDEX attendance_employee_no_event_id (employee_no, event_id)
      `);
      console.log('Added unique constraint for attendance');
    } catch (error) {
      if (error.code === 'ER_DUP_KEYNAME') {
        console.log('Unique constraint for attendance already exists');
      } else {
        throw error;
      }
    }

    try {
      await sequelize.query(`
        ALTER TABLE events 
        ADD UNIQUE INDEX events_type_name (event_type, event_name)
      `);
      console.log('Added unique constraint for events');
    } catch (error) {
      if (error.code === 'ER_DUP_KEYNAME') {
        console.log('Unique constraint for events already exists');
      } else {
        throw error;
      }
    }

    console.log('All unique constraints added successfully!');
    
  } catch (error) {
    console.error('Error during cleanup:', error);
    throw error;
  }
}

// Run cleanup if this file is executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  cleanupDuplicates()
    .then(() => {
      console.log('Migration completed successfully');
      process.exit(0);
    })
    .catch((error) => {
      console.error('Migration failed:', error);
      process.exit(1);
    });
}

`

employees.routes.js
`
import { Router } from 'express';
import { body, validationResult } from 'express-validator';
import { Dmag } from '../../core/models.js';
import { requireAuth } from '../_shared/auth-middleware.js';

export const employeesRouter = Router();

employeesRouter.get('/by-number/:employee_no', requireAuth, async (req, res, next) => {
  try {
    const employee = await Dmag.findOne({ where: { employee_no: req.params.employee_no } });
    if (!employee) return res.status(404).json({ error: 'Employee not found' });
    res.json({ employee_no: employee.employee_no, employee_name: employee.employee_name, department: employee.department });
  } catch (e) {
    next(e);
  }
});

employeesRouter.get('/departments', requireAuth, async (req, res, next) => {
  try {
    const { getUniqueDepartments } = await import('../../core/models.js');
    const departments = await getUniqueDepartments();
    res.json(departments.map(d => d.department));
  } catch (e) {
    next(e);
  }
});

employeesRouter.get('/departments', requireAuth, async (req, res, next) => {
  try {
    const departments = await sequelize.query(
      `SELECT DISTINCT department as department FROM dmags WHERE department IS NOT NULL ORDER BY department`,
      { type: sequelize.QueryTypes.SELECT }
    );
    res.json(departments.map(d => d.department).filter(Boolean));
  } catch (e) {
    console.error('GET /employees/departments error:', e);
    next(e);
  }
});`

evaluations.routes.js
`
import { Router } from 'express';
import multer from 'multer';
import XLSX from 'xlsx';
import { body, validationResult } from 'express-validator';
import { sequelize } from '../../core/db.js'; // Import Op if not already
import { Evaluation, Event } from '../../core/models.js'; // Assume Evaluation defined in models.js
import { requireAuth } from '../_shared/auth-middleware.js';
import { Op } from 'sequelize';

const upload = multer({ storage: multer.memoryStorage() });
export const evaluationsRouter = Router();

// GET /evaluations - Paginated list with event filter, search, sorting (match Attendance)
evaluationsRouter.get('/', requireAuth, async (req, res, next) => {
  try {
    const { 
      page = 1, 
      limit = 10, 
      sort = 'evaluation_id', 
      order = 'DESC', 
      event_id,
      search 
    } = req.query;
    const offset = (Number(page) - 1) * Number(limit);
    
    const where = {};
    if (event_id) where.event_id = Number(event_id);
    if (search) {
      where[Op.or] = [
        { employee_name: { [Op.iLike]: `%${search}%` } },
        { employee_no: { [Op.iLike]: `%${search}%` } }
      ];
    }
    
    const include = [{
      model: Event,
      attributes: ['event_id', 'event_name']
    }];
    
    const { count, rows } = await Evaluation.findAndCountAll({
      where,
      include,
      order: [[sort, order.toUpperCase()]],
      limit: Number(limit),
      offset
    });
    
    res.json({
      evaluations: rows,
      pagination: {
        total: count,
        page: Number(page),
        limit: Number(limit),
        totalPages: Math.ceil(count / limit)
      }
    });
  } catch (e) {
    console.error('GET /evaluations error:', e);
    next(e);
  }
});

// POST /evaluations/bulk-delete - Bulk delete by IDs
evaluationsRouter.post('/bulk-delete', requireAuth, async (req, res, next) => {
  try {
    const { ids } = req.body;
    if (!Array.isArray(ids) || ids.length === 0) {
      return res.status(400).json({ error: 'Invalid IDs array' });
    }
    if (ids.length > 1000) { // Arbitrary limit for safety
      return res.status(400).json({ error: 'Too many IDs (max 1000)' });
    }
    
    const deletedCount = await Evaluation.destroy({
      where: { evaluation_id: ids }
    });
    
    res.json({ deleted: deletedCount, message: `${deletedCount} evaluations deleted` });
  } catch (e) {
    console.error('POST /evaluations/bulk-delete error:', e);
    next(e);
  }
});

// GET /evaluations/export - Export filtered data as Excel
evaluationsRouter.get('/export', requireAuth, async (req, res, next) => {
  try {
    const { event_id, format = 'xlsx' } = req.query;
    const where = event_id ? { event_id: Number(event_id) } : {};
    
    const evaluations = await Evaluation.findAll({
      where,
      include: [{ model: Event, attributes: ['event_name'] }]
    });
    
    // Map to export data (headers + rows)
    const headers = [
      'Employee No', 'Employee Name', 'Event Name', 'Objectives Met', 'Relevance', 'Venue',
      'Activity', 'Value of Time Spent', 'Overall Rating', 'Topic Clear Effective',
      'Answered Questions', 'Presentation Materials', 'Session Helpful'
    ];
    const rows = evaluations.map(e => [
      e.employee_no || '', e.employee_name, e.event.event_name,
      e.objectives_met || 'NA', e.relevance || 'NA', e.venue || 'NA',
      e.activity || 'NA', e.value_time_spent || 'NA', e.overall_rating || 'NA',
      e.topic_clear_effective || 'NA', e.answered_questions || 'NA',
      e.presentation_materials || 'NA', e.session_helpful || 'NA'
    ]);
    
    const data = [headers, ...rows];
    const ws = XLSX.utils.aoa_to_sheet(data);
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Evaluations');
    
    const buffer = XLSX.write(wb, { type: 'buffer', bookType: format });
    res.setHeader('Content-Type', `application/vnd.openxmlformats-officedocument.spreadsheetml.sheet`);
    res.setHeader('Content-Disposition', `attachment; filename=evaluations-${new Date().toISOString().split('T')[0]}.${format}`);
    res.send(buffer);
  } catch (e) {
    console.error('GET /evaluations/export error:', e);
    next(e);
  }
});

// POST /evaluations - Create (retained, with minor validation tweaks)
evaluationsRouter.post(
  '/',
  requireAuth,
  [
    body('employee_no').optional().trim(),
    body('employee_name').notEmpty().trim().escape(),
    body('event_id').isInt({ min: 1 }),
    body('objectives_met').optional().isIn(['1', '2', '3', '4', '5', 'NA']),
    body('relevance').optional().isIn(['1', '2', '3', '4', '5', 'NA']),
    body('venue').optional().isIn(['1', '2', '3', '4', '5', 'NA']),
    body('activity').optional().isIn(['1', '2', '3', '4', '5', 'NA']),
    body('value_time_spent').optional().isIn(['1', '2', '3', '4', '5', 'NA']),
    body('overall_rating').optional().isIn(['1', '2', '3', '4', '5', 'NA']),
    body('topic_clear_effective').optional().isIn(['1', '2', '3', '4', '5', 'NA']),
    body('answered_questions').optional().isIn(['1', '2', '3', '4', '5', 'NA']),
    body('presentation_materials').optional().isIn(['1', '2', '3', '4', '5', 'NA']),
    body('session_helpful').optional().isIn(['Yes', 'No'])
  ],
  async (req, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) {
        return res.status(400).json({ error: 'Validation failed', details: errors.array() });
      }
      
      const { event_id, employee_no, employee_name, ...ratings } = req.body;
      const finalEmployeeNo = employee_no?.trim() || null;
      
      // Duplicate check
      const existing = await Evaluation.findOne({
        where: {
          event_id: Number(event_id),
          [Op.or]: [
            finalEmployeeNo ? { employee_no: finalEmployeeNo } : null,
            { employee_name: employee_name.trim() }
          ].filter(Boolean)
        }
      });
      
      if (existing) {
        return res.status(409).json({ 
          error: 'Duplicate evaluation found',
          details: `Evaluation for "${employee_name.trim()}" in event ${event_id} already exists`
        });
      }
      
      const created = await Evaluation.create({
        employee_no: finalEmployeeNo,
        employee_name: employee_name.trim(),
        event_id: Number(event_id),
        ...ratings
      });
      
      res.status(201).json(created);
    } catch (e) {
      if (e.name === 'SequelizeUniqueConstraintError') {
        return res.status(409).json({ error: 'Duplicate evaluation', details: 'Unique constraint violated' });
      }
      next(e);
    }
  }
);

// PUT /evaluations/:id - Update (retained)
evaluationsRouter.put(
  '/:id',
  requireAuth,
  [ /* Same validations as POST, optional for updates */ ],
  async (req, res, next) => {
    try {
      const errors = validationResult(req);
      if (!errors.isEmpty()) return res.status(400).json({ error: 'Validation failed', details: errors.array() });
      
      const evaluation = await Evaluation.findByPk(req.params.id);
      if (!evaluation) return res.status(404).json({ error: 'Evaluation not found' });
      
      const { event_id, employee_no, employee_name, ...ratings } = req.body;
      const updateData = {
        ...(employee_name && { employee_name: employee_name.trim() }),
        ...(employee_no && { employee_no: employee_no.trim() }),
        ...(event_id && { event_id: Number(event_id) }),
        ...ratings
      };
      
      // Duplicate check excluding self
      const existing = await Evaluation.findOne({
        where: {
          ...updateData,
          evaluation_id: { [Op.ne]: req.params.id }
        }
      });
      
      if (existing) {
        return res.status(409).json({ error: 'Duplicate evaluation found' });
      }
      
      await evaluation.update(updateData);
      res.json(evaluation);
    } catch (e) {
      next(e);
    }
  }
);

// DELETE /evaluations/:id (retained)
evaluationsRouter.delete('/:id', requireAuth, async (req, res, next) => {
  try {
    const evaluation = await Evaluation.findByPk(req.params.id);
    if (!evaluation) return res.status(404).json({ error: 'Evaluation not found' });
    await evaluation.destroy();
    res.json({ message: 'Evaluation deleted successfully' });
  } catch (e) {
    next(e);
  }
});

// POST /evaluations/upload - Enhanced for Excel (with skipping)
// POST /evaluations/upload - Enhanced for Excel with DB duplicate check
evaluationsRouter.post('/upload', requireAuth, upload.single('file'), async (req, res, next) => {
  try {
    const { buffer } = req.file || {};
    if (!buffer) return res.status(400).json({ error: 'No file uploaded' });
    
    const workbook = XLSX.read(buffer, { type: 'buffer' });
    const sheet = workbook.Sheets[workbook.SheetNames[0]];
    const rows = XLSX.utils.sheet_to_json(sheet, { defval: '' });
    
    const created = [];
    const skipped = [];
    const seen = new Map(); // Track batch duplicates
    
    for (const row of rows) {
      const employee_no = (row['Employee No'] || '').toString().trim();
      const employee_name = (row['Employee Name'] || '').toString().trim();
      const event_name = (row['Event Name'] || '').toString().trim();
      const finalEmployeeNo = employee_no || null;
      
      if (!employee_name || !event_name) {
        skipped.push({ employee_name, event_name, reason: 'Missing name or event' });
        continue;
      }
      
      const event = await Event.findOne({ where: { event_name: { [Op.iLike]: event_name } } });
      if (!event) {
        skipped.push({ employee_name, event_name, reason: `Event "${event_name}" not found` });
        continue;
      }
      
      // Parse ratings (unchanged)
      const ratings = {};
      const ratingFields = {
        'Objectives Met': 'objectives_met',
        'Relevance': 'relevance',
        'Venue': 'venue',
        'Activity': 'activity',
        'Value of Time Spent': 'value_time_spent',
        'Overall Rating': 'overall_rating',
        'Discussed Topic Clearly and Effectively': 'topic_clear_effective',
        'Answered Questions Appropriately': 'answered_questions',
        'Presentation/Materials': 'presentation_materials',
        'Session Helpful': 'session_helpful'
      };
      let validRow = true;
      for (const [col, field] of Object.entries(ratingFields)) {
        const val = (row[col] || 'NA').toString().trim().toUpperCase();
        if (['1','2','3','4','5','NA'].includes(val) || 
            (field === 'session_helpful' && ['YES','NO'].includes(val))) {
          ratings[field] = val === 'YES' ? 'Yes' : (val === 'NO' ? 'No' : val.toLowerCase());
        } else {
          skipped.push({ employee_name, event_name, reason: `Invalid ${field}: ${val}` });
          validRow = false;
          break;
        }
      }
      if (!validRow) continue;
      
      // Batch duplicate key
      const batchKey = finalEmployeeNo 
        ? `${finalEmployeeNo}_${event.event_id}` 
        : `${employee_name.toLowerCase()}_${event.event_id}`;
      
      if (seen.has(batchKey)) {
        skipped.push({ employee_name, event_name, reason: 'Duplicate in upload batch' });
        continue;
      }
      seen.set(batchKey, true);
      
      // NEW: DB duplicate check (exact match on key)
      const dbExisting = await Evaluation.findOne({
        where: {
          event_id: event.event_id,
          [Op.or]: [
            finalEmployeeNo ? { employee_no: finalEmployeeNo } : null,
            { employee_name }
          ].filter(Boolean)
        }
      });
      
      if (dbExisting) {
        skipped.push({ 
          employee_name, 
          event_name, 
          reason: `Duplicate exists in database for "${employee_name}" in event "${event_name}"` 
        });
        continue;
      }
      
      const record = await Evaluation.create({
        employee_no: finalEmployeeNo,
        employee_name,
        event_id: event.event_id,
        ...ratings
      });
      created.push(record);
    }
    
    const response = { inserted: created.length };
    if (skipped.length > 0) {
      response.skipped = skipped.length;
      response.skip_details = skipped;
    }
    res.json(response);
  } catch (e) {
    console.error('POST /evaluations/upload error:', e);
    next(e);
  }
});

// GET /evaluations/template - Excel template (enhanced from CSV)
evaluationsRouter.get('/template', requireAuth, async (req, res, next) => {
  try {
    const events = await Event.findAll({ attributes: ['event_id', 'event_name'] });
    
    // Main template sheet
    const headers = [
      'Employee No', 'Employee Name', 'Event Name', 'Objectives Met', 'Relevance', 'Venue',
      'Activity', 'Value of Time Spent', 'Overall Rating', 'Discussed Topic Clearly and Effectively',
      'Answered Questions Appropriately', 'Presentation/Materials', 'Session Helpful'
    ];
    const sampleRow = ['', 'Sample Name', 'Sample Event', '5', '4', '5', '4', '5', '5', '5', '4', '5', 'Yes'];
    const ws = XLSX.utils.aoa_to_sheet([headers, sampleRow]);
    
    // Events reference sheet
    const eventsData = [['Event ID', 'Event Name']];
    events.forEach(event => eventsData.push([event.event_id, event.event_name]));
    const eventsWs = XLSX.utils.aoa_to_sheet(eventsData);
    
    const wb = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(wb, ws, 'Evaluation Template');
    XLSX.utils.book_append_sheet(wb, eventsWs, 'Events Reference');
    
    const buffer = XLSX.write(wb, { type: 'buffer', bookType: 'xlsx' });
    res.setHeader('Content-Type', 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
    res.setHeader('Content-Disposition', 'attachment; filename=evaluation-template.xlsx');
    res.send(buffer);
  } catch (e) {
    console.error('GET /evaluations/template error:', e);
    next(e);
  }
});`